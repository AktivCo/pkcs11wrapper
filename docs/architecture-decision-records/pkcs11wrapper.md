# pkcs11wrapper ADR

Коротко - некоторые ключевые моменты по использованию, реализации и архитектуре.

## Общее

* Библиотека не имеет зависимостей (зависимость констант от pkcs11jna должна быть удалена при первой необходимости), так
  ее просто поддерживать и просто встраивать;
* Библиотека полностью повторяет интерфейс pkcs11 (версии 2.40 на данный момент). Не добавляет каких-то новых
  абстракций. Не содержит типичных юзкейсов (типа TokenManager, или Pkcs11Facade, синглтон, который зовет initialize и
  т.д.). Нейминг стремится максимально повторять pkcs11 стандарт, но с учетом Java-специфики;
* Делает интерфейс pkcs11 объектно-ориентированным и удобным для вызова из Java. API должно выглядеть неотличимо от
  обычного Java кода. API pkcs11wrapper полностью маскирует и нивелирует влияние С-интерфейса;
* Приложение может работать с несколькими pkcs11wrapper (например, с разными low level бэкендами);
* pkcs11wrapper разделен на 2 главных слоя. Low level - 100% скрывает взаимодействие с С++. High level - используя low
  level, предоставляет удобное расширенное и упрощенное Java API;
* Реализация Java-C++ маппингов (JNA) полностью отделима и может быть подменена другой (сейчас есть только Jna и Fake),
  но это может быть что угодно: от JNI до взаимодействия с токеном по сети;
* Клиентский код обязан "не знать" о том, какой low level использует pkcs11wrapper. Также API pkcs11wrapper не может
  зависеть от pkcs11, который лежит под ним (если он вообще есть). Однако классы, которые реализуют сам low level слой,
  могут расcчитывать на то, что pkcs11wrapper проинициализирован правильно, и могут кастить интерфейсы к ожидаемым
  имплементациям;
* pkcs11wrapper предоставляет возможности для расширения пользователям. Rutoken EX интерфейс реализован через API
  расширений. Частично этот механизм повторяет то, что сказано в стандарте, например, про vendor defined значения. Также
  довольно часто для расширения используется наследование;
* Runtime-ошибок самого pkcs11wrapper не существует, он в этом плане максимально прозрачный. Ошибки уровня pkcs11wrapper
  стоит ожидать, только если его неправильно используют. Когда pkcs11 возвращает что-то непонятное для pkcs11wrapper, то
  последний должен не порождать ошибку, а делать все возможное, чтобы отдать управление пользователю (пример -
  UnknownValueSupplier). Успешная операция в pkcs11 == успешная операция в pkcs11wrapper.

## API

* Такие классы как module/slot/token/session/managers/etc. содержат ссылки на своих предшественников. Так пользователь
  всегда имеет доступ ко всему API pkcs11, фабрикам и т.д., имея ссылку только на один любой объект. Также ему нет
  необходимости писать огромные цепочки методов getSomething().getOtherThing(). При этом объекты-данные - DTO (как
  Pkcs11TokenInfo, Pkcs11Attribute) - таких ссылок не имеют, иначе их было бы сложнее инстанцировать;
* Пользователь всегда может спуститься на low level и поработать с C-подобным интерфейсом pkcs11, если ему нужен полный
  контроль над операциями;
* Иерархии Pkcs11Attribute и Pkcs11BaseObject поддерживают 2 типа интерфейса: обобщенный и специализированный
  (предпочтительный). Пользователь может выполнять любые операции с любым объектом через обобщенный интерфейс, но это
  будет менее типобезопасно (слабее типизация), чем то же самое через специализированный интерфейс;
* Checked exceptions не используются;
* Числовые константы pkcs11 обычно представлены в Java в виде enum. Когда какой-то метод может возвращать/принимать
  разные enum, необходимо использовать для них общий интерфейс; так реализованы все enum, которые по стандарту разрешают
  расширение vendor-defined значениями. Для расширяемых enum в API никогда не должен фигурировать сам enum, а только
  общий интерфейс;
* Пользователи легко могут объявлять свои enum с группами констант, и так же легко при желании могут передавать в
  pkcs11wrapper голые значения (как анонимный объект или лямбду).

## Данные (DTO)

* pkcs11wrapper не проверяет и не валидирует данные. Проверка входных/выходных данных производится только в случае, если
  pkcs11wrapper сам как-то использует данные. Одновременно с этим мы хотим выжать максимум из строгой типизации и
  сделать интерфейс таким, чтобы его было сложно использовать неправильно и легко использовать правильно;
* Некоторые данные идут только в одном направлении (например, в pkcs11), другие только возвращаются из pkcs11, самые
  сложные идут в обоих направлениях. Обычно такие данные имеют самый сложный интерфейс, например, Pkcs11Attribute. В
  зависимости от этого в соответствующих datatype интерфейсах могут быть либо только сеттеры (если данные идут только в
  pkcs11), либо только геттеры (если данные только возвращаются из pkcs11), либо и сеттеры, и геттеры (если данные идут
  в обоих направлениях);
* Большинство классов данных (DTO) обладает свойством immutability;
* Значения констант в enum не должны повторяться. Это вызывает сложности при сравнении с членами enum и получении
  инстанса enum по числовому значению. Поэтому повторяющиеся значения реализуются как алиасы (выносятся в static поля);
* Параметры функций помечаются @Nullable только в тех случаях, когда вызов этих функций с null-аргументами является
  допустимым, т.е. при передаче таких данных pkcs11 не возвращает ошибку.

## Additional Features

Дополнительная функциональность, которую реализует pkcs11wrapper:

* Генерация шаблона объекта по Java-классу;
* Поиск объектов по Java-классу;
* Автоматический вывод Java-класса объекта при чтении с токена (на основе чтения атрибутов).
